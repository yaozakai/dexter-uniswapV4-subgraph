// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import { Address, BigInt, Bytes, ethereum, TypedMap } from '@graphprotocol/graph-ts'

export class Approval extends ethereum.Event {
  get params(): Approval__Params {
    return new Approval__Params(this)
  }
}

export class Approval__Params {
  _event: Approval

  constructor(event: Approval) {
    this._event = event
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get spender(): Address {
    return this._event.parameters[1].value.toAddress()
  }

  get id(): BigInt {
    return this._event.parameters[2].value.toBigInt()
  }
}

export class ApprovalForAll extends ethereum.Event {
  get params(): ApprovalForAll__Params {
    return new ApprovalForAll__Params(this)
  }
}

export class ApprovalForAll__Params {
  _event: ApprovalForAll

  constructor(event: ApprovalForAll) {
    this._event = event
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get operator(): Address {
    return this._event.parameters[1].value.toAddress()
  }

  get approved(): boolean {
    return this._event.parameters[2].value.toBoolean()
  }
}

export class Subscription extends ethereum.Event {
  get params(): Subscription__Params {
    return new Subscription__Params(this)
  }
}

export class Subscription__Params {
  _event: Subscription

  constructor(event: Subscription) {
    this._event = event
  }

  get tokenId(): BigInt {
    return this._event.parameters[0].value.toBigInt()
  }

  get subscriber(): Address {
    return this._event.parameters[1].value.toAddress()
  }
}

export class Transfer extends ethereum.Event {
  get params(): Transfer__Params {
    return new Transfer__Params(this)
  }
}

export class Transfer__Params {
  _event: Transfer

  constructor(event: Transfer) {
    this._event = event
  }

  get from(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress()
  }

  get id(): BigInt {
    return this._event.parameters[2].value.toBigInt()
  }
}

export class Unsubscription extends ethereum.Event {
  get params(): Unsubscription__Params {
    return new Unsubscription__Params(this)
  }
}

export class Unsubscription__Params {
  _event: Unsubscription

  constructor(event: Unsubscription) {
    this._event = event
  }

  get tokenId(): BigInt {
    return this._event.parameters[0].value.toBigInt()
  }

  get subscriber(): Address {
    return this._event.parameters[1].value.toAddress()
  }
}

export class PositionManager__getPoolAndPositionInfoResultPoolKeyStruct extends ethereum.Tuple {
  get currency0(): Address {
    return this[0].toAddress()
  }

  get currency1(): Address {
    return this[1].toAddress()
  }

  get fee(): i32 {
    return this[2].toI32()
  }

  get tickSpacing(): i32 {
    return this[3].toI32()
  }

  get hooks(): Address {
    return this[4].toAddress()
  }
}

export class PositionManager__getPoolAndPositionInfoResult {
  value0: PositionManager__getPoolAndPositionInfoResultPoolKeyStruct
  value1: BigInt

  constructor(value0: PositionManager__getPoolAndPositionInfoResultPoolKeyStruct, value1: BigInt) {
    this.value0 = value0
    this.value1 = value1
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>()
    map.set('value0', ethereum.Value.fromTuple(this.value0))
    map.set('value1', ethereum.Value.fromUnsignedBigInt(this.value1))
    return map
  }

  getPoolKey(): PositionManager__getPoolAndPositionInfoResultPoolKeyStruct {
    return this.value0
  }

  getInfo(): BigInt {
    return this.value1
  }
}

export class PositionManager__poolKeysResult {
  value0: Address
  value1: Address
  value2: i32
  value3: i32
  value4: Address

  constructor(value0: Address, value1: Address, value2: i32, value3: i32, value4: Address) {
    this.value0 = value0
    this.value1 = value1
    this.value2 = value2
    this.value3 = value3
    this.value4 = value4
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>()
    map.set('value0', ethereum.Value.fromAddress(this.value0))
    map.set('value1', ethereum.Value.fromAddress(this.value1))
    map.set('value2', ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(this.value2)))
    map.set('value3', ethereum.Value.fromI32(this.value3))
    map.set('value4', ethereum.Value.fromAddress(this.value4))
    return map
  }

  getCurrency0(): Address {
    return this.value0
  }

  getCurrency1(): Address {
    return this.value1
  }

  getFee(): i32 {
    return this.value2
  }

  getTickSpacing(): i32 {
    return this.value3
  }

  getHooks(): Address {
    return this.value4
  }
}

export class PositionManager extends ethereum.SmartContract {
  static bind(address: Address): PositionManager {
    return new PositionManager('PositionManager', address)
  }

  DOMAIN_SEPARATOR(): Bytes {
    const result = super.call('DOMAIN_SEPARATOR', 'DOMAIN_SEPARATOR():(bytes32)', [])

    return result[0].toBytes()
  }

  try_DOMAIN_SEPARATOR(): ethereum.CallResult<Bytes> {
    const result = super.tryCall('DOMAIN_SEPARATOR', 'DOMAIN_SEPARATOR():(bytes32)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    const value = result.value
    return ethereum.CallResult.fromValue(value[0].toBytes())
  }

  balanceOf(owner: Address): BigInt {
    const result = super.call('balanceOf', 'balanceOf(address):(uint256)', [ethereum.Value.fromAddress(owner)])

    return result[0].toBigInt()
  }

  try_balanceOf(owner: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall('balanceOf', 'balanceOf(address):(uint256)', [ethereum.Value.fromAddress(owner)])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    const value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  getApproved(param0: BigInt): Address {
    const result = super.call('getApproved', 'getApproved(uint256):(address)', [
      ethereum.Value.fromUnsignedBigInt(param0),
    ])

    return result[0].toAddress()
  }

  try_getApproved(param0: BigInt): ethereum.CallResult<Address> {
    const result = super.tryCall('getApproved', 'getApproved(uint256):(address)', [
      ethereum.Value.fromUnsignedBigInt(param0),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    const value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }

  getPoolAndPositionInfo(tokenId: BigInt): PositionManager__getPoolAndPositionInfoResult {
    const result = super.call(
      'getPoolAndPositionInfo',
      'getPoolAndPositionInfo(uint256):((address,address,uint24,int24,address),uint256)',
      [ethereum.Value.fromUnsignedBigInt(tokenId)],
    )

    return changetype<PositionManager__getPoolAndPositionInfoResult>(
      new PositionManager__getPoolAndPositionInfoResult(
        changetype<PositionManager__getPoolAndPositionInfoResultPoolKeyStruct>(result[0].toTuple()),
        result[1].toBigInt(),
      ),
    )
  }

  try_getPoolAndPositionInfo(tokenId: BigInt): ethereum.CallResult<PositionManager__getPoolAndPositionInfoResult> {
    const result = super.tryCall(
      'getPoolAndPositionInfo',
      'getPoolAndPositionInfo(uint256):((address,address,uint24,int24,address),uint256)',
      [ethereum.Value.fromUnsignedBigInt(tokenId)],
    )
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    const value = result.value
    return ethereum.CallResult.fromValue(
      changetype<PositionManager__getPoolAndPositionInfoResult>(
        new PositionManager__getPoolAndPositionInfoResult(
          changetype<PositionManager__getPoolAndPositionInfoResultPoolKeyStruct>(value[0].toTuple()),
          value[1].toBigInt(),
        ),
      ),
    )
  }

  getPositionLiquidity(tokenId: BigInt): BigInt {
    const result = super.call('getPositionLiquidity', 'getPositionLiquidity(uint256):(uint128)', [
      ethereum.Value.fromUnsignedBigInt(tokenId),
    ])

    return result[0].toBigInt()
  }

  try_getPositionLiquidity(tokenId: BigInt): ethereum.CallResult<BigInt> {
    const result = super.tryCall('getPositionLiquidity', 'getPositionLiquidity(uint256):(uint128)', [
      ethereum.Value.fromUnsignedBigInt(tokenId),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    const value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  isApprovedForAll(param0: Address, param1: Address): boolean {
    const result = super.call('isApprovedForAll', 'isApprovedForAll(address,address):(bool)', [
      ethereum.Value.fromAddress(param0),
      ethereum.Value.fromAddress(param1),
    ])

    return result[0].toBoolean()
  }

  try_isApprovedForAll(param0: Address, param1: Address): ethereum.CallResult<boolean> {
    const result = super.tryCall('isApprovedForAll', 'isApprovedForAll(address,address):(bool)', [
      ethereum.Value.fromAddress(param0),
      ethereum.Value.fromAddress(param1),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    const value = result.value
    return ethereum.CallResult.fromValue(value[0].toBoolean())
  }

  msgSender(): Address {
    const result = super.call('msgSender', 'msgSender():(address)', [])

    return result[0].toAddress()
  }

  try_msgSender(): ethereum.CallResult<Address> {
    const result = super.tryCall('msgSender', 'msgSender():(address)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    const value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }

  name(): string {
    const result = super.call('name', 'name():(string)', [])

    return result[0].toString()
  }

  try_name(): ethereum.CallResult<string> {
    const result = super.tryCall('name', 'name():(string)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    const value = result.value
    return ethereum.CallResult.fromValue(value[0].toString())
  }

  nextTokenId(): BigInt {
    const result = super.call('nextTokenId', 'nextTokenId():(uint256)', [])

    return result[0].toBigInt()
  }

  try_nextTokenId(): ethereum.CallResult<BigInt> {
    const result = super.tryCall('nextTokenId', 'nextTokenId():(uint256)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    const value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  nonces(owner: Address, word: BigInt): BigInt {
    const result = super.call('nonces', 'nonces(address,uint256):(uint256)', [
      ethereum.Value.fromAddress(owner),
      ethereum.Value.fromUnsignedBigInt(word),
    ])

    return result[0].toBigInt()
  }

  try_nonces(owner: Address, word: BigInt): ethereum.CallResult<BigInt> {
    const result = super.tryCall('nonces', 'nonces(address,uint256):(uint256)', [
      ethereum.Value.fromAddress(owner),
      ethereum.Value.fromUnsignedBigInt(word),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    const value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  ownerOf(id: BigInt): Address {
    const result = super.call('ownerOf', 'ownerOf(uint256):(address)', [ethereum.Value.fromUnsignedBigInt(id)])

    return result[0].toAddress()
  }

  try_ownerOf(id: BigInt): ethereum.CallResult<Address> {
    const result = super.tryCall('ownerOf', 'ownerOf(uint256):(address)', [ethereum.Value.fromUnsignedBigInt(id)])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    const value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }

  permit2(): Address {
    const result = super.call('permit2', 'permit2():(address)', [])

    return result[0].toAddress()
  }

  try_permit2(): ethereum.CallResult<Address> {
    const result = super.tryCall('permit2', 'permit2():(address)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    const value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }

  poolKeys(poolId: Bytes): PositionManager__poolKeysResult {
    const result = super.call('poolKeys', 'poolKeys(bytes25):(address,address,uint24,int24,address)', [
      ethereum.Value.fromFixedBytes(poolId),
    ])

    return new PositionManager__poolKeysResult(
      result[0].toAddress(),
      result[1].toAddress(),
      result[2].toI32(),
      result[3].toI32(),
      result[4].toAddress(),
    )
  }

  try_poolKeys(poolId: Bytes): ethereum.CallResult<PositionManager__poolKeysResult> {
    const result = super.tryCall('poolKeys', 'poolKeys(bytes25):(address,address,uint24,int24,address)', [
      ethereum.Value.fromFixedBytes(poolId),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    const value = result.value
    return ethereum.CallResult.fromValue(
      new PositionManager__poolKeysResult(
        value[0].toAddress(),
        value[1].toAddress(),
        value[2].toI32(),
        value[3].toI32(),
        value[4].toAddress(),
      ),
    )
  }

  poolManager(): Address {
    const result = super.call('poolManager', 'poolManager():(address)', [])

    return result[0].toAddress()
  }

  try_poolManager(): ethereum.CallResult<Address> {
    const result = super.tryCall('poolManager', 'poolManager():(address)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    const value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }

  positionInfo(tokenId: BigInt): BigInt {
    const result = super.call('positionInfo', 'positionInfo(uint256):(uint256)', [
      ethereum.Value.fromUnsignedBigInt(tokenId),
    ])

    return result[0].toBigInt()
  }

  try_positionInfo(tokenId: BigInt): ethereum.CallResult<BigInt> {
    const result = super.tryCall('positionInfo', 'positionInfo(uint256):(uint256)', [
      ethereum.Value.fromUnsignedBigInt(tokenId),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    const value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  subscriber(tokenId: BigInt): Address {
    const result = super.call('subscriber', 'subscriber(uint256):(address)', [
      ethereum.Value.fromUnsignedBigInt(tokenId),
    ])

    return result[0].toAddress()
  }

  try_subscriber(tokenId: BigInt): ethereum.CallResult<Address> {
    const result = super.tryCall('subscriber', 'subscriber(uint256):(address)', [
      ethereum.Value.fromUnsignedBigInt(tokenId),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    const value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }

  supportsInterface(interfaceId: Bytes): boolean {
    const result = super.call('supportsInterface', 'supportsInterface(bytes4):(bool)', [
      ethereum.Value.fromFixedBytes(interfaceId),
    ])

    return result[0].toBoolean()
  }

  try_supportsInterface(interfaceId: Bytes): ethereum.CallResult<boolean> {
    const result = super.tryCall('supportsInterface', 'supportsInterface(bytes4):(bool)', [
      ethereum.Value.fromFixedBytes(interfaceId),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    const value = result.value
    return ethereum.CallResult.fromValue(value[0].toBoolean())
  }

  symbol(): string {
    const result = super.call('symbol', 'symbol():(string)', [])

    return result[0].toString()
  }

  try_symbol(): ethereum.CallResult<string> {
    const result = super.tryCall('symbol', 'symbol():(string)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    const value = result.value
    return ethereum.CallResult.fromValue(value[0].toString())
  }

  tokenURI(param0: BigInt): string {
    const result = super.call('tokenURI', 'tokenURI(uint256):(string)', [ethereum.Value.fromUnsignedBigInt(param0)])

    return result[0].toString()
  }

  try_tokenURI(param0: BigInt): ethereum.CallResult<string> {
    const result = super.tryCall('tokenURI', 'tokenURI(uint256):(string)', [ethereum.Value.fromUnsignedBigInt(param0)])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    const value = result.value
    return ethereum.CallResult.fromValue(value[0].toString())
  }

  unlockCallback(data: Bytes): Bytes {
    const result = super.call('unlockCallback', 'unlockCallback(bytes):(bytes)', [ethereum.Value.fromBytes(data)])

    return result[0].toBytes()
  }

  try_unlockCallback(data: Bytes): ethereum.CallResult<Bytes> {
    const result = super.tryCall('unlockCallback', 'unlockCallback(bytes):(bytes)', [ethereum.Value.fromBytes(data)])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    const value = result.value
    return ethereum.CallResult.fromValue(value[0].toBytes())
  }

  unsubscribeGasLimit(): BigInt {
    const result = super.call('unsubscribeGasLimit', 'unsubscribeGasLimit():(uint256)', [])

    return result[0].toBigInt()
  }

  try_unsubscribeGasLimit(): ethereum.CallResult<BigInt> {
    const result = super.tryCall('unsubscribeGasLimit', 'unsubscribeGasLimit():(uint256)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    const value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this)
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this)
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall

  constructor(call: ConstructorCall) {
    this._call = call
  }

  get _poolManager(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get _permit2(): Address {
    return this._call.inputValues[1].value.toAddress()
  }

  get _unsubscribeGasLimit(): BigInt {
    return this._call.inputValues[2].value.toBigInt()
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall

  constructor(call: ConstructorCall) {
    this._call = call
  }
}

export class ApproveCall extends ethereum.Call {
  get inputs(): ApproveCall__Inputs {
    return new ApproveCall__Inputs(this)
  }

  get outputs(): ApproveCall__Outputs {
    return new ApproveCall__Outputs(this)
  }
}

export class ApproveCall__Inputs {
  _call: ApproveCall

  constructor(call: ApproveCall) {
    this._call = call
  }

  get spender(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get id(): BigInt {
    return this._call.inputValues[1].value.toBigInt()
  }
}

export class ApproveCall__Outputs {
  _call: ApproveCall

  constructor(call: ApproveCall) {
    this._call = call
  }
}

export class InitializePoolCall extends ethereum.Call {
  get inputs(): InitializePoolCall__Inputs {
    return new InitializePoolCall__Inputs(this)
  }

  get outputs(): InitializePoolCall__Outputs {
    return new InitializePoolCall__Outputs(this)
  }
}

export class InitializePoolCall__Inputs {
  _call: InitializePoolCall

  constructor(call: InitializePoolCall) {
    this._call = call
  }

  get key(): InitializePoolCallKeyStruct {
    return changetype<InitializePoolCallKeyStruct>(this._call.inputValues[0].value.toTuple())
  }

  get sqrtPriceX96(): BigInt {
    return this._call.inputValues[1].value.toBigInt()
  }

  get hookData(): Bytes {
    return this._call.inputValues[2].value.toBytes()
  }
}

export class InitializePoolCall__Outputs {
  _call: InitializePoolCall

  constructor(call: InitializePoolCall) {
    this._call = call
  }

  get value0(): i32 {
    return this._call.outputValues[0].value.toI32()
  }
}

export class InitializePoolCallKeyStruct extends ethereum.Tuple {
  get currency0(): Address {
    return this[0].toAddress()
  }

  get currency1(): Address {
    return this[1].toAddress()
  }

  get fee(): i32 {
    return this[2].toI32()
  }

  get tickSpacing(): i32 {
    return this[3].toI32()
  }

  get hooks(): Address {
    return this[4].toAddress()
  }
}

export class ModifyLiquiditiesCall extends ethereum.Call {
  get inputs(): ModifyLiquiditiesCall__Inputs {
    return new ModifyLiquiditiesCall__Inputs(this)
  }

  get outputs(): ModifyLiquiditiesCall__Outputs {
    return new ModifyLiquiditiesCall__Outputs(this)
  }
}

export class ModifyLiquiditiesCall__Inputs {
  _call: ModifyLiquiditiesCall

  constructor(call: ModifyLiquiditiesCall) {
    this._call = call
  }

  get unlockData(): Bytes {
    return this._call.inputValues[0].value.toBytes()
  }

  get deadline(): BigInt {
    return this._call.inputValues[1].value.toBigInt()
  }
}

export class ModifyLiquiditiesCall__Outputs {
  _call: ModifyLiquiditiesCall

  constructor(call: ModifyLiquiditiesCall) {
    this._call = call
  }
}

export class ModifyLiquiditiesWithoutUnlockCall extends ethereum.Call {
  get inputs(): ModifyLiquiditiesWithoutUnlockCall__Inputs {
    return new ModifyLiquiditiesWithoutUnlockCall__Inputs(this)
  }

  get outputs(): ModifyLiquiditiesWithoutUnlockCall__Outputs {
    return new ModifyLiquiditiesWithoutUnlockCall__Outputs(this)
  }
}

export class ModifyLiquiditiesWithoutUnlockCall__Inputs {
  _call: ModifyLiquiditiesWithoutUnlockCall

  constructor(call: ModifyLiquiditiesWithoutUnlockCall) {
    this._call = call
  }

  get actions(): Bytes {
    return this._call.inputValues[0].value.toBytes()
  }

  get params(): Array<Bytes> {
    return this._call.inputValues[1].value.toBytesArray()
  }
}

export class ModifyLiquiditiesWithoutUnlockCall__Outputs {
  _call: ModifyLiquiditiesWithoutUnlockCall

  constructor(call: ModifyLiquiditiesWithoutUnlockCall) {
    this._call = call
  }
}

export class MulticallCall extends ethereum.Call {
  get inputs(): MulticallCall__Inputs {
    return new MulticallCall__Inputs(this)
  }

  get outputs(): MulticallCall__Outputs {
    return new MulticallCall__Outputs(this)
  }
}

export class MulticallCall__Inputs {
  _call: MulticallCall

  constructor(call: MulticallCall) {
    this._call = call
  }

  get data(): Array<Bytes> {
    return this._call.inputValues[0].value.toBytesArray()
  }
}

export class MulticallCall__Outputs {
  _call: MulticallCall

  constructor(call: MulticallCall) {
    this._call = call
  }

  get results(): Array<Bytes> {
    return this._call.outputValues[0].value.toBytesArray()
  }
}

export class PermitCall extends ethereum.Call {
  get inputs(): PermitCall__Inputs {
    return new PermitCall__Inputs(this)
  }

  get outputs(): PermitCall__Outputs {
    return new PermitCall__Outputs(this)
  }
}

export class PermitCall__Inputs {
  _call: PermitCall

  constructor(call: PermitCall) {
    this._call = call
  }

  get spender(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get tokenId(): BigInt {
    return this._call.inputValues[1].value.toBigInt()
  }

  get deadline(): BigInt {
    return this._call.inputValues[2].value.toBigInt()
  }

  get nonce(): BigInt {
    return this._call.inputValues[3].value.toBigInt()
  }

  get signature(): Bytes {
    return this._call.inputValues[4].value.toBytes()
  }
}

export class PermitCall__Outputs {
  _call: PermitCall

  constructor(call: PermitCall) {
    this._call = call
  }
}

export class Permit1Call extends ethereum.Call {
  get inputs(): Permit1Call__Inputs {
    return new Permit1Call__Inputs(this)
  }

  get outputs(): Permit1Call__Outputs {
    return new Permit1Call__Outputs(this)
  }
}

export class Permit1Call__Inputs {
  _call: Permit1Call

  constructor(call: Permit1Call) {
    this._call = call
  }

  get owner(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get permitSingle(): Permit1CallPermitSingleStruct {
    return changetype<Permit1CallPermitSingleStruct>(this._call.inputValues[1].value.toTuple())
  }

  get signature(): Bytes {
    return this._call.inputValues[2].value.toBytes()
  }
}

export class Permit1Call__Outputs {
  _call: Permit1Call

  constructor(call: Permit1Call) {
    this._call = call
  }

  get err(): Bytes {
    return this._call.outputValues[0].value.toBytes()
  }
}

export class Permit1CallPermitSingleStruct extends ethereum.Tuple {
  get details(): Permit1CallPermitSingleDetailsStruct {
    return changetype<Permit1CallPermitSingleDetailsStruct>(this[0].toTuple())
  }

  get spender(): Address {
    return this[1].toAddress()
  }

  get sigDeadline(): BigInt {
    return this[2].toBigInt()
  }
}

export class Permit1CallPermitSingleDetailsStruct extends ethereum.Tuple {
  get token(): Address {
    return this[0].toAddress()
  }

  get amount(): BigInt {
    return this[1].toBigInt()
  }

  get expiration(): BigInt {
    return this[2].toBigInt()
  }

  get nonce(): BigInt {
    return this[3].toBigInt()
  }
}

export class PermitBatchCall extends ethereum.Call {
  get inputs(): PermitBatchCall__Inputs {
    return new PermitBatchCall__Inputs(this)
  }

  get outputs(): PermitBatchCall__Outputs {
    return new PermitBatchCall__Outputs(this)
  }
}

export class PermitBatchCall__Inputs {
  _call: PermitBatchCall

  constructor(call: PermitBatchCall) {
    this._call = call
  }

  get owner(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get _permitBatch(): PermitBatchCall_permitBatchStruct {
    return changetype<PermitBatchCall_permitBatchStruct>(this._call.inputValues[1].value.toTuple())
  }

  get signature(): Bytes {
    return this._call.inputValues[2].value.toBytes()
  }
}

export class PermitBatchCall__Outputs {
  _call: PermitBatchCall

  constructor(call: PermitBatchCall) {
    this._call = call
  }

  get err(): Bytes {
    return this._call.outputValues[0].value.toBytes()
  }
}

export class PermitBatchCall_permitBatchStruct extends ethereum.Tuple {
  get details(): Array<PermitBatchCall_permitBatchDetailsStruct> {
    return this[0].toTupleArray<PermitBatchCall_permitBatchDetailsStruct>()
  }

  get spender(): Address {
    return this[1].toAddress()
  }

  get sigDeadline(): BigInt {
    return this[2].toBigInt()
  }
}

export class PermitBatchCall_permitBatchDetailsStruct extends ethereum.Tuple {
  get token(): Address {
    return this[0].toAddress()
  }

  get amount(): BigInt {
    return this[1].toBigInt()
  }

  get expiration(): BigInt {
    return this[2].toBigInt()
  }

  get nonce(): BigInt {
    return this[3].toBigInt()
  }
}

export class PermitForAllCall extends ethereum.Call {
  get inputs(): PermitForAllCall__Inputs {
    return new PermitForAllCall__Inputs(this)
  }

  get outputs(): PermitForAllCall__Outputs {
    return new PermitForAllCall__Outputs(this)
  }
}

export class PermitForAllCall__Inputs {
  _call: PermitForAllCall

  constructor(call: PermitForAllCall) {
    this._call = call
  }

  get owner(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get operator(): Address {
    return this._call.inputValues[1].value.toAddress()
  }

  get approved(): boolean {
    return this._call.inputValues[2].value.toBoolean()
  }

  get deadline(): BigInt {
    return this._call.inputValues[3].value.toBigInt()
  }

  get nonce(): BigInt {
    return this._call.inputValues[4].value.toBigInt()
  }

  get signature(): Bytes {
    return this._call.inputValues[5].value.toBytes()
  }
}

export class PermitForAllCall__Outputs {
  _call: PermitForAllCall

  constructor(call: PermitForAllCall) {
    this._call = call
  }
}

export class RevokeNonceCall extends ethereum.Call {
  get inputs(): RevokeNonceCall__Inputs {
    return new RevokeNonceCall__Inputs(this)
  }

  get outputs(): RevokeNonceCall__Outputs {
    return new RevokeNonceCall__Outputs(this)
  }
}

export class RevokeNonceCall__Inputs {
  _call: RevokeNonceCall

  constructor(call: RevokeNonceCall) {
    this._call = call
  }

  get nonce(): BigInt {
    return this._call.inputValues[0].value.toBigInt()
  }
}

export class RevokeNonceCall__Outputs {
  _call: RevokeNonceCall

  constructor(call: RevokeNonceCall) {
    this._call = call
  }
}

export class SafeTransferFromCall extends ethereum.Call {
  get inputs(): SafeTransferFromCall__Inputs {
    return new SafeTransferFromCall__Inputs(this)
  }

  get outputs(): SafeTransferFromCall__Outputs {
    return new SafeTransferFromCall__Outputs(this)
  }
}

export class SafeTransferFromCall__Inputs {
  _call: SafeTransferFromCall

  constructor(call: SafeTransferFromCall) {
    this._call = call
  }

  get from(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress()
  }

  get id(): BigInt {
    return this._call.inputValues[2].value.toBigInt()
  }
}

export class SafeTransferFromCall__Outputs {
  _call: SafeTransferFromCall

  constructor(call: SafeTransferFromCall) {
    this._call = call
  }
}

export class SafeTransferFrom1Call extends ethereum.Call {
  get inputs(): SafeTransferFrom1Call__Inputs {
    return new SafeTransferFrom1Call__Inputs(this)
  }

  get outputs(): SafeTransferFrom1Call__Outputs {
    return new SafeTransferFrom1Call__Outputs(this)
  }
}

export class SafeTransferFrom1Call__Inputs {
  _call: SafeTransferFrom1Call

  constructor(call: SafeTransferFrom1Call) {
    this._call = call
  }

  get from(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress()
  }

  get id(): BigInt {
    return this._call.inputValues[2].value.toBigInt()
  }

  get data(): Bytes {
    return this._call.inputValues[3].value.toBytes()
  }
}

export class SafeTransferFrom1Call__Outputs {
  _call: SafeTransferFrom1Call

  constructor(call: SafeTransferFrom1Call) {
    this._call = call
  }
}

export class SetApprovalForAllCall extends ethereum.Call {
  get inputs(): SetApprovalForAllCall__Inputs {
    return new SetApprovalForAllCall__Inputs(this)
  }

  get outputs(): SetApprovalForAllCall__Outputs {
    return new SetApprovalForAllCall__Outputs(this)
  }
}

export class SetApprovalForAllCall__Inputs {
  _call: SetApprovalForAllCall

  constructor(call: SetApprovalForAllCall) {
    this._call = call
  }

  get operator(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get approved(): boolean {
    return this._call.inputValues[1].value.toBoolean()
  }
}

export class SetApprovalForAllCall__Outputs {
  _call: SetApprovalForAllCall

  constructor(call: SetApprovalForAllCall) {
    this._call = call
  }
}

export class SubscribeCall extends ethereum.Call {
  get inputs(): SubscribeCall__Inputs {
    return new SubscribeCall__Inputs(this)
  }

  get outputs(): SubscribeCall__Outputs {
    return new SubscribeCall__Outputs(this)
  }
}

export class SubscribeCall__Inputs {
  _call: SubscribeCall

  constructor(call: SubscribeCall) {
    this._call = call
  }

  get tokenId(): BigInt {
    return this._call.inputValues[0].value.toBigInt()
  }

  get newSubscriber(): Address {
    return this._call.inputValues[1].value.toAddress()
  }

  get data(): Bytes {
    return this._call.inputValues[2].value.toBytes()
  }
}

export class SubscribeCall__Outputs {
  _call: SubscribeCall

  constructor(call: SubscribeCall) {
    this._call = call
  }
}

export class TransferFromCall extends ethereum.Call {
  get inputs(): TransferFromCall__Inputs {
    return new TransferFromCall__Inputs(this)
  }

  get outputs(): TransferFromCall__Outputs {
    return new TransferFromCall__Outputs(this)
  }
}

export class TransferFromCall__Inputs {
  _call: TransferFromCall

  constructor(call: TransferFromCall) {
    this._call = call
  }

  get from(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress()
  }

  get id(): BigInt {
    return this._call.inputValues[2].value.toBigInt()
  }
}

export class TransferFromCall__Outputs {
  _call: TransferFromCall

  constructor(call: TransferFromCall) {
    this._call = call
  }
}

export class UnlockCallbackCall extends ethereum.Call {
  get inputs(): UnlockCallbackCall__Inputs {
    return new UnlockCallbackCall__Inputs(this)
  }

  get outputs(): UnlockCallbackCall__Outputs {
    return new UnlockCallbackCall__Outputs(this)
  }
}

export class UnlockCallbackCall__Inputs {
  _call: UnlockCallbackCall

  constructor(call: UnlockCallbackCall) {
    this._call = call
  }

  get data(): Bytes {
    return this._call.inputValues[0].value.toBytes()
  }
}

export class UnlockCallbackCall__Outputs {
  _call: UnlockCallbackCall

  constructor(call: UnlockCallbackCall) {
    this._call = call
  }

  get value0(): Bytes {
    return this._call.outputValues[0].value.toBytes()
  }
}

export class UnsubscribeCall extends ethereum.Call {
  get inputs(): UnsubscribeCall__Inputs {
    return new UnsubscribeCall__Inputs(this)
  }

  get outputs(): UnsubscribeCall__Outputs {
    return new UnsubscribeCall__Outputs(this)
  }
}

export class UnsubscribeCall__Inputs {
  _call: UnsubscribeCall

  constructor(call: UnsubscribeCall) {
    this._call = call
  }

  get tokenId(): BigInt {
    return this._call.inputValues[0].value.toBigInt()
  }
}

export class UnsubscribeCall__Outputs {
  _call: UnsubscribeCall

  constructor(call: UnsubscribeCall) {
    this._call = call
  }
}
