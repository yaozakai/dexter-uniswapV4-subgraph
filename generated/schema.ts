// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import { BigDecimal, BigInt, Bytes, Entity, store, Value, ValueKind } from '@graphprotocol/graph-ts'

export class PoolManager extends Entity {
  constructor(id: string) {
    super()
    this.set('id', Value.fromString(id))
  }

  save(): void {
    const id = this.get('id')
    assert(id != null, 'Cannot save PoolManager entity without an ID')
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PoolManager must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      )
      store.set('PoolManager', id.toString(), this)
    }
  }

  static loadInBlock(id: string): PoolManager | null {
    return changetype<PoolManager | null>(store.get_in_block('PoolManager', id))
  }

  static load(id: string): PoolManager | null {
    return changetype<PoolManager | null>(store.get('PoolManager', id))
  }

  get id(): string {
    const value = this.get('id')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set id(value: string) {
    this.set('id', Value.fromString(value))
  }

  get poolCount(): BigInt {
    const value = this.get('poolCount')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set poolCount(value: BigInt) {
    this.set('poolCount', Value.fromBigInt(value))
  }

  get txCount(): BigInt {
    const value = this.get('txCount')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set txCount(value: BigInt) {
    this.set('txCount', Value.fromBigInt(value))
  }

  get totalVolumeUSD(): BigDecimal {
    const value = this.get('totalVolumeUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set totalVolumeUSD(value: BigDecimal) {
    this.set('totalVolumeUSD', Value.fromBigDecimal(value))
  }

  get totalVolumeETH(): BigDecimal {
    const value = this.get('totalVolumeETH')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set totalVolumeETH(value: BigDecimal) {
    this.set('totalVolumeETH', Value.fromBigDecimal(value))
  }

  get totalFeesUSD(): BigDecimal {
    const value = this.get('totalFeesUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set totalFeesUSD(value: BigDecimal) {
    this.set('totalFeesUSD', Value.fromBigDecimal(value))
  }

  get totalFeesETH(): BigDecimal {
    const value = this.get('totalFeesETH')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set totalFeesETH(value: BigDecimal) {
    this.set('totalFeesETH', Value.fromBigDecimal(value))
  }

  get untrackedVolumeUSD(): BigDecimal {
    const value = this.get('untrackedVolumeUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set untrackedVolumeUSD(value: BigDecimal) {
    this.set('untrackedVolumeUSD', Value.fromBigDecimal(value))
  }

  get totalValueLockedUSD(): BigDecimal {
    const value = this.get('totalValueLockedUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set totalValueLockedUSD(value: BigDecimal) {
    this.set('totalValueLockedUSD', Value.fromBigDecimal(value))
  }

  get totalValueLockedETH(): BigDecimal {
    const value = this.get('totalValueLockedETH')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set totalValueLockedETH(value: BigDecimal) {
    this.set('totalValueLockedETH', Value.fromBigDecimal(value))
  }

  get totalValueLockedUSDUntracked(): BigDecimal {
    const value = this.get('totalValueLockedUSDUntracked')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set totalValueLockedUSDUntracked(value: BigDecimal) {
    this.set('totalValueLockedUSDUntracked', Value.fromBigDecimal(value))
  }

  get totalValueLockedETHUntracked(): BigDecimal {
    const value = this.get('totalValueLockedETHUntracked')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set totalValueLockedETHUntracked(value: BigDecimal) {
    this.set('totalValueLockedETHUntracked', Value.fromBigDecimal(value))
  }

  get owner(): string {
    const value = this.get('owner')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set owner(value: string) {
    this.set('owner', Value.fromString(value))
  }
}

export class Bundle extends Entity {
  constructor(id: string) {
    super()
    this.set('id', Value.fromString(id))
  }

  save(): void {
    const id = this.get('id')
    assert(id != null, 'Cannot save Bundle entity without an ID')
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Bundle must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      )
      store.set('Bundle', id.toString(), this)
    }
  }

  static loadInBlock(id: string): Bundle | null {
    return changetype<Bundle | null>(store.get_in_block('Bundle', id))
  }

  static load(id: string): Bundle | null {
    return changetype<Bundle | null>(store.get('Bundle', id))
  }

  get id(): string {
    const value = this.get('id')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set id(value: string) {
    this.set('id', Value.fromString(value))
  }

  get ethPriceUSD(): BigDecimal {
    const value = this.get('ethPriceUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set ethPriceUSD(value: BigDecimal) {
    this.set('ethPriceUSD', Value.fromBigDecimal(value))
  }
}

export class Token extends Entity {
  constructor(id: string) {
    super()
    this.set('id', Value.fromString(id))
  }

  save(): void {
    const id = this.get('id')
    assert(id != null, 'Cannot save Token entity without an ID')
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Token must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      )
      store.set('Token', id.toString(), this)
    }
  }

  static loadInBlock(id: string): Token | null {
    return changetype<Token | null>(store.get_in_block('Token', id))
  }

  static load(id: string): Token | null {
    return changetype<Token | null>(store.get('Token', id))
  }

  get id(): string {
    const value = this.get('id')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set id(value: string) {
    this.set('id', Value.fromString(value))
  }

  get symbol(): string {
    const value = this.get('symbol')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set symbol(value: string) {
    this.set('symbol', Value.fromString(value))
  }

  get name(): string {
    const value = this.get('name')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set name(value: string) {
    this.set('name', Value.fromString(value))
  }

  get decimals(): BigInt {
    const value = this.get('decimals')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set decimals(value: BigInt) {
    this.set('decimals', Value.fromBigInt(value))
  }

  get totalSupply(): BigInt {
    const value = this.get('totalSupply')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set totalSupply(value: BigInt) {
    this.set('totalSupply', Value.fromBigInt(value))
  }

  get volume(): BigDecimal {
    const value = this.get('volume')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set volume(value: BigDecimal) {
    this.set('volume', Value.fromBigDecimal(value))
  }

  get volumeUSD(): BigDecimal {
    const value = this.get('volumeUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set volumeUSD(value: BigDecimal) {
    this.set('volumeUSD', Value.fromBigDecimal(value))
  }

  get untrackedVolumeUSD(): BigDecimal {
    const value = this.get('untrackedVolumeUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set untrackedVolumeUSD(value: BigDecimal) {
    this.set('untrackedVolumeUSD', Value.fromBigDecimal(value))
  }

  get feesUSD(): BigDecimal {
    const value = this.get('feesUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set feesUSD(value: BigDecimal) {
    this.set('feesUSD', Value.fromBigDecimal(value))
  }

  get txCount(): BigInt {
    const value = this.get('txCount')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set txCount(value: BigInt) {
    this.set('txCount', Value.fromBigInt(value))
  }

  get poolCount(): BigInt {
    const value = this.get('poolCount')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set poolCount(value: BigInt) {
    this.set('poolCount', Value.fromBigInt(value))
  }

  get totalValueLocked(): BigDecimal {
    const value = this.get('totalValueLocked')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set totalValueLocked(value: BigDecimal) {
    this.set('totalValueLocked', Value.fromBigDecimal(value))
  }

  get totalValueLockedUSD(): BigDecimal {
    const value = this.get('totalValueLockedUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set totalValueLockedUSD(value: BigDecimal) {
    this.set('totalValueLockedUSD', Value.fromBigDecimal(value))
  }

  get totalValueLockedUSDUntracked(): BigDecimal {
    const value = this.get('totalValueLockedUSDUntracked')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set totalValueLockedUSDUntracked(value: BigDecimal) {
    this.set('totalValueLockedUSDUntracked', Value.fromBigDecimal(value))
  }

  get derivedETH(): BigDecimal {
    const value = this.get('derivedETH')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set derivedETH(value: BigDecimal) {
    this.set('derivedETH', Value.fromBigDecimal(value))
  }

  get whitelistPools(): Array<string> {
    const value = this.get('whitelistPools')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toStringArray()
    }
  }

  set whitelistPools(value: Array<string>) {
    this.set('whitelistPools', Value.fromStringArray(value))
  }

  get tokenDayData(): TokenDayDataLoader {
    return new TokenDayDataLoader('Token', this.get('id')!.toString(), 'tokenDayData')
  }
}

export class Pool extends Entity {
  constructor(id: string) {
    super()
    this.set('id', Value.fromString(id))
  }

  save(): void {
    const id = this.get('id')
    assert(id != null, 'Cannot save Pool entity without an ID')
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Pool must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      )
      store.set('Pool', id.toString(), this)
    }
  }

  static loadInBlock(id: string): Pool | null {
    return changetype<Pool | null>(store.get_in_block('Pool', id))
  }

  static load(id: string): Pool | null {
    return changetype<Pool | null>(store.get('Pool', id))
  }

  get id(): string {
    const value = this.get('id')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set id(value: string) {
    this.set('id', Value.fromString(value))
  }

  get createdAtTimestamp(): BigInt {
    const value = this.get('createdAtTimestamp')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set createdAtTimestamp(value: BigInt) {
    this.set('createdAtTimestamp', Value.fromBigInt(value))
  }

  get createdAtBlockNumber(): BigInt {
    const value = this.get('createdAtBlockNumber')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set createdAtBlockNumber(value: BigInt) {
    this.set('createdAtBlockNumber', Value.fromBigInt(value))
  }

  get token0(): string {
    const value = this.get('token0')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set token0(value: string) {
    this.set('token0', Value.fromString(value))
  }

  get token1(): string {
    const value = this.get('token1')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set token1(value: string) {
    this.set('token1', Value.fromString(value))
  }

  get feeTier(): BigInt {
    const value = this.get('feeTier')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set feeTier(value: BigInt) {
    this.set('feeTier', Value.fromBigInt(value))
  }

  get liquidity(): BigInt {
    const value = this.get('liquidity')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set liquidity(value: BigInt) {
    this.set('liquidity', Value.fromBigInt(value))
  }

  get sqrtPrice(): BigInt {
    const value = this.get('sqrtPrice')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set sqrtPrice(value: BigInt) {
    this.set('sqrtPrice', Value.fromBigInt(value))
  }

  get token0Price(): BigDecimal {
    const value = this.get('token0Price')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set token0Price(value: BigDecimal) {
    this.set('token0Price', Value.fromBigDecimal(value))
  }

  get token1Price(): BigDecimal {
    const value = this.get('token1Price')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set token1Price(value: BigDecimal) {
    this.set('token1Price', Value.fromBigDecimal(value))
  }

  get tick(): BigInt | null {
    const value = this.get('tick')
    if (!value || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toBigInt()
    }
  }

  set tick(value: BigInt | null) {
    if (!value) {
      this.unset('tick')
    } else {
      this.set('tick', Value.fromBigInt(<BigInt>value))
    }
  }

  get tickSpacing(): BigInt {
    const value = this.get('tickSpacing')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set tickSpacing(value: BigInt) {
    this.set('tickSpacing', Value.fromBigInt(value))
  }

  get observationIndex(): BigInt {
    const value = this.get('observationIndex')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set observationIndex(value: BigInt) {
    this.set('observationIndex', Value.fromBigInt(value))
  }

  get volumeToken0(): BigDecimal {
    const value = this.get('volumeToken0')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set volumeToken0(value: BigDecimal) {
    this.set('volumeToken0', Value.fromBigDecimal(value))
  }

  get volumeToken1(): BigDecimal {
    const value = this.get('volumeToken1')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set volumeToken1(value: BigDecimal) {
    this.set('volumeToken1', Value.fromBigDecimal(value))
  }

  get volumeUSD(): BigDecimal {
    const value = this.get('volumeUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set volumeUSD(value: BigDecimal) {
    this.set('volumeUSD', Value.fromBigDecimal(value))
  }

  get untrackedVolumeUSD(): BigDecimal {
    const value = this.get('untrackedVolumeUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set untrackedVolumeUSD(value: BigDecimal) {
    this.set('untrackedVolumeUSD', Value.fromBigDecimal(value))
  }

  get feesUSD(): BigDecimal {
    const value = this.get('feesUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set feesUSD(value: BigDecimal) {
    this.set('feesUSD', Value.fromBigDecimal(value))
  }

  get txCount(): BigInt {
    const value = this.get('txCount')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set txCount(value: BigInt) {
    this.set('txCount', Value.fromBigInt(value))
  }

  get collectedFeesToken0(): BigDecimal {
    const value = this.get('collectedFeesToken0')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set collectedFeesToken0(value: BigDecimal) {
    this.set('collectedFeesToken0', Value.fromBigDecimal(value))
  }

  get collectedFeesToken1(): BigDecimal {
    const value = this.get('collectedFeesToken1')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set collectedFeesToken1(value: BigDecimal) {
    this.set('collectedFeesToken1', Value.fromBigDecimal(value))
  }

  get collectedFeesUSD(): BigDecimal {
    const value = this.get('collectedFeesUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set collectedFeesUSD(value: BigDecimal) {
    this.set('collectedFeesUSD', Value.fromBigDecimal(value))
  }

  get totalValueLockedToken0(): BigDecimal {
    const value = this.get('totalValueLockedToken0')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set totalValueLockedToken0(value: BigDecimal) {
    this.set('totalValueLockedToken0', Value.fromBigDecimal(value))
  }

  get totalValueLockedToken1(): BigDecimal {
    const value = this.get('totalValueLockedToken1')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set totalValueLockedToken1(value: BigDecimal) {
    this.set('totalValueLockedToken1', Value.fromBigDecimal(value))
  }

  get totalValueLockedETH(): BigDecimal {
    const value = this.get('totalValueLockedETH')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set totalValueLockedETH(value: BigDecimal) {
    this.set('totalValueLockedETH', Value.fromBigDecimal(value))
  }

  get totalValueLockedUSD(): BigDecimal {
    const value = this.get('totalValueLockedUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set totalValueLockedUSD(value: BigDecimal) {
    this.set('totalValueLockedUSD', Value.fromBigDecimal(value))
  }

  get totalValueLockedUSDUntracked(): BigDecimal {
    const value = this.get('totalValueLockedUSDUntracked')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set totalValueLockedUSDUntracked(value: BigDecimal) {
    this.set('totalValueLockedUSDUntracked', Value.fromBigDecimal(value))
  }

  get liquidityProviderCount(): BigInt {
    const value = this.get('liquidityProviderCount')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set liquidityProviderCount(value: BigInt) {
    this.set('liquidityProviderCount', Value.fromBigInt(value))
  }

  get poolHourData(): PoolHourDataLoader {
    return new PoolHourDataLoader('Pool', this.get('id')!.toString(), 'poolHourData')
  }

  get poolDayData(): PoolDayDataLoader {
    return new PoolDayDataLoader('Pool', this.get('id')!.toString(), 'poolDayData')
  }

  get hooks(): string {
    const value = this.get('hooks')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set hooks(value: string) {
    this.set('hooks', Value.fromString(value))
  }

  get modifyLiquiditys(): ModifyLiquidityLoader {
    return new ModifyLiquidityLoader('Pool', this.get('id')!.toString(), 'modifyLiquiditys')
  }

  get swaps(): SwapLoader {
    return new SwapLoader('Pool', this.get('id')!.toString(), 'swaps')
  }

  get ticks(): TickLoader {
    return new TickLoader('Pool', this.get('id')!.toString(), 'ticks')
  }
}

export class Tick extends Entity {
  constructor(id: string) {
    super()
    this.set('id', Value.fromString(id))
  }

  save(): void {
    const id = this.get('id')
    assert(id != null, 'Cannot save Tick entity without an ID')
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Tick must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      )
      store.set('Tick', id.toString(), this)
    }
  }

  static loadInBlock(id: string): Tick | null {
    return changetype<Tick | null>(store.get_in_block('Tick', id))
  }

  static load(id: string): Tick | null {
    return changetype<Tick | null>(store.get('Tick', id))
  }

  get id(): string {
    const value = this.get('id')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set id(value: string) {
    this.set('id', Value.fromString(value))
  }

  get poolAddress(): string | null {
    const value = this.get('poolAddress')
    if (!value || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toString()
    }
  }

  set poolAddress(value: string | null) {
    if (!value) {
      this.unset('poolAddress')
    } else {
      this.set('poolAddress', Value.fromString(<string>value))
    }
  }

  get tickIdx(): BigInt {
    const value = this.get('tickIdx')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set tickIdx(value: BigInt) {
    this.set('tickIdx', Value.fromBigInt(value))
  }

  get pool(): string {
    const value = this.get('pool')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set pool(value: string) {
    this.set('pool', Value.fromString(value))
  }

  get liquidityGross(): BigInt {
    const value = this.get('liquidityGross')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set liquidityGross(value: BigInt) {
    this.set('liquidityGross', Value.fromBigInt(value))
  }

  get liquidityNet(): BigInt {
    const value = this.get('liquidityNet')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set liquidityNet(value: BigInt) {
    this.set('liquidityNet', Value.fromBigInt(value))
  }

  get price0(): BigDecimal {
    const value = this.get('price0')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set price0(value: BigDecimal) {
    this.set('price0', Value.fromBigDecimal(value))
  }

  get price1(): BigDecimal {
    const value = this.get('price1')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set price1(value: BigDecimal) {
    this.set('price1', Value.fromBigDecimal(value))
  }

  get createdAtTimestamp(): BigInt {
    const value = this.get('createdAtTimestamp')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set createdAtTimestamp(value: BigInt) {
    this.set('createdAtTimestamp', Value.fromBigInt(value))
  }

  get createdAtBlockNumber(): BigInt {
    const value = this.get('createdAtBlockNumber')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set createdAtBlockNumber(value: BigInt) {
    this.set('createdAtBlockNumber', Value.fromBigInt(value))
  }
}

export class Transaction extends Entity {
  constructor(id: string) {
    super()
    this.set('id', Value.fromString(id))
  }

  save(): void {
    const id = this.get('id')
    assert(id != null, 'Cannot save Transaction entity without an ID')
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Transaction must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      )
      store.set('Transaction', id.toString(), this)
    }
  }

  static loadInBlock(id: string): Transaction | null {
    return changetype<Transaction | null>(store.get_in_block('Transaction', id))
  }

  static load(id: string): Transaction | null {
    return changetype<Transaction | null>(store.get('Transaction', id))
  }

  get id(): string {
    const value = this.get('id')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set id(value: string) {
    this.set('id', Value.fromString(value))
  }

  get blockNumber(): BigInt {
    const value = this.get('blockNumber')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set blockNumber(value: BigInt) {
    this.set('blockNumber', Value.fromBigInt(value))
  }

  get timestamp(): BigInt {
    const value = this.get('timestamp')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set timestamp(value: BigInt) {
    this.set('timestamp', Value.fromBigInt(value))
  }

  get gasUsed(): BigInt {
    const value = this.get('gasUsed')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set gasUsed(value: BigInt) {
    this.set('gasUsed', Value.fromBigInt(value))
  }

  get gasPrice(): BigInt {
    const value = this.get('gasPrice')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set gasPrice(value: BigInt) {
    this.set('gasPrice', Value.fromBigInt(value))
  }

  get modifyLiquiditys(): ModifyLiquidityLoader {
    return new ModifyLiquidityLoader('Transaction', this.get('id')!.toString(), 'modifyLiquiditys')
  }

  get swaps(): SwapLoader {
    return new SwapLoader('Transaction', this.get('id')!.toString(), 'swaps')
  }

  get transfers(): TransferLoader {
    return new TransferLoader('Transaction', this.get('id')!.toString(), 'transfers')
  }

  get subscriptions(): SubscribeLoader {
    return new SubscribeLoader('Transaction', this.get('id')!.toString(), 'subscriptions')
  }

  get unsubscriptions(): UnsubscribeLoader {
    return new UnsubscribeLoader('Transaction', this.get('id')!.toString(), 'unsubscriptions')
  }
}

export class Swap extends Entity {
  constructor(id: string) {
    super()
    this.set('id', Value.fromString(id))
  }

  save(): void {
    const id = this.get('id')
    assert(id != null, 'Cannot save Swap entity without an ID')
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Swap must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      )
      store.set('Swap', id.toString(), this)
    }
  }

  static loadInBlock(id: string): Swap | null {
    return changetype<Swap | null>(store.get_in_block('Swap', id))
  }

  static load(id: string): Swap | null {
    return changetype<Swap | null>(store.get('Swap', id))
  }

  get id(): string {
    const value = this.get('id')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set id(value: string) {
    this.set('id', Value.fromString(value))
  }

  get transaction(): string {
    const value = this.get('transaction')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set transaction(value: string) {
    this.set('transaction', Value.fromString(value))
  }

  get timestamp(): BigInt {
    const value = this.get('timestamp')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set timestamp(value: BigInt) {
    this.set('timestamp', Value.fromBigInt(value))
  }

  get pool(): string {
    const value = this.get('pool')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set pool(value: string) {
    this.set('pool', Value.fromString(value))
  }

  get token0(): string {
    const value = this.get('token0')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set token0(value: string) {
    this.set('token0', Value.fromString(value))
  }

  get token1(): string {
    const value = this.get('token1')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set token1(value: string) {
    this.set('token1', Value.fromString(value))
  }

  get sender(): Bytes {
    const value = this.get('sender')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBytes()
    }
  }

  set sender(value: Bytes) {
    this.set('sender', Value.fromBytes(value))
  }

  get origin(): Bytes {
    const value = this.get('origin')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBytes()
    }
  }

  set origin(value: Bytes) {
    this.set('origin', Value.fromBytes(value))
  }

  get amount0(): BigDecimal {
    const value = this.get('amount0')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set amount0(value: BigDecimal) {
    this.set('amount0', Value.fromBigDecimal(value))
  }

  get amount1(): BigDecimal {
    const value = this.get('amount1')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set amount1(value: BigDecimal) {
    this.set('amount1', Value.fromBigDecimal(value))
  }

  get amountUSD(): BigDecimal {
    const value = this.get('amountUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set amountUSD(value: BigDecimal) {
    this.set('amountUSD', Value.fromBigDecimal(value))
  }

  get sqrtPriceX96(): BigInt {
    const value = this.get('sqrtPriceX96')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set sqrtPriceX96(value: BigInt) {
    this.set('sqrtPriceX96', Value.fromBigInt(value))
  }

  get tick(): BigInt {
    const value = this.get('tick')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set tick(value: BigInt) {
    this.set('tick', Value.fromBigInt(value))
  }

  get logIndex(): BigInt | null {
    const value = this.get('logIndex')
    if (!value || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toBigInt()
    }
  }

  set logIndex(value: BigInt | null) {
    if (!value) {
      this.unset('logIndex')
    } else {
      this.set('logIndex', Value.fromBigInt(<BigInt>value))
    }
  }
}

export class ModifyLiquidity extends Entity {
  constructor(id: string) {
    super()
    this.set('id', Value.fromString(id))
  }

  save(): void {
    const id = this.get('id')
    assert(id != null, 'Cannot save ModifyLiquidity entity without an ID')
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ModifyLiquidity must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      )
      store.set('ModifyLiquidity', id.toString(), this)
    }
  }

  static loadInBlock(id: string): ModifyLiquidity | null {
    return changetype<ModifyLiquidity | null>(store.get_in_block('ModifyLiquidity', id))
  }

  static load(id: string): ModifyLiquidity | null {
    return changetype<ModifyLiquidity | null>(store.get('ModifyLiquidity', id))
  }

  get id(): string {
    const value = this.get('id')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set id(value: string) {
    this.set('id', Value.fromString(value))
  }

  get transaction(): string {
    const value = this.get('transaction')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set transaction(value: string) {
    this.set('transaction', Value.fromString(value))
  }

  get timestamp(): BigInt {
    const value = this.get('timestamp')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set timestamp(value: BigInt) {
    this.set('timestamp', Value.fromBigInt(value))
  }

  get pool(): string {
    const value = this.get('pool')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set pool(value: string) {
    this.set('pool', Value.fromString(value))
  }

  get token0(): string {
    const value = this.get('token0')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set token0(value: string) {
    this.set('token0', Value.fromString(value))
  }

  get token1(): string {
    const value = this.get('token1')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set token1(value: string) {
    this.set('token1', Value.fromString(value))
  }

  get sender(): Bytes | null {
    const value = this.get('sender')
    if (!value || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toBytes()
    }
  }

  set sender(value: Bytes | null) {
    if (!value) {
      this.unset('sender')
    } else {
      this.set('sender', Value.fromBytes(<Bytes>value))
    }
  }

  get origin(): Bytes {
    const value = this.get('origin')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBytes()
    }
  }

  set origin(value: Bytes) {
    this.set('origin', Value.fromBytes(value))
  }

  get amount(): BigInt {
    const value = this.get('amount')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set amount(value: BigInt) {
    this.set('amount', Value.fromBigInt(value))
  }

  get amount0(): BigDecimal {
    const value = this.get('amount0')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set amount0(value: BigDecimal) {
    this.set('amount0', Value.fromBigDecimal(value))
  }

  get amount1(): BigDecimal {
    const value = this.get('amount1')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set amount1(value: BigDecimal) {
    this.set('amount1', Value.fromBigDecimal(value))
  }

  get amountUSD(): BigDecimal | null {
    const value = this.get('amountUSD')
    if (!value || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toBigDecimal()
    }
  }

  set amountUSD(value: BigDecimal | null) {
    if (!value) {
      this.unset('amountUSD')
    } else {
      this.set('amountUSD', Value.fromBigDecimal(<BigDecimal>value))
    }
  }

  get tickLower(): BigInt {
    const value = this.get('tickLower')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set tickLower(value: BigInt) {
    this.set('tickLower', Value.fromBigInt(value))
  }

  get tickUpper(): BigInt {
    const value = this.get('tickUpper')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set tickUpper(value: BigInt) {
    this.set('tickUpper', Value.fromBigInt(value))
  }

  get logIndex(): BigInt | null {
    const value = this.get('logIndex')
    if (!value || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toBigInt()
    }
  }

  set logIndex(value: BigInt | null) {
    if (!value) {
      this.unset('logIndex')
    } else {
      this.set('logIndex', Value.fromBigInt(<BigInt>value))
    }
  }
}

export class UniswapDayData extends Entity {
  constructor(id: string) {
    super()
    this.set('id', Value.fromString(id))
  }

  save(): void {
    const id = this.get('id')
    assert(id != null, 'Cannot save UniswapDayData entity without an ID')
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UniswapDayData must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      )
      store.set('UniswapDayData', id.toString(), this)
    }
  }

  static loadInBlock(id: string): UniswapDayData | null {
    return changetype<UniswapDayData | null>(store.get_in_block('UniswapDayData', id))
  }

  static load(id: string): UniswapDayData | null {
    return changetype<UniswapDayData | null>(store.get('UniswapDayData', id))
  }

  get id(): string {
    const value = this.get('id')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set id(value: string) {
    this.set('id', Value.fromString(value))
  }

  get date(): i32 {
    const value = this.get('date')
    if (!value || value.kind == ValueKind.NULL) {
      return 0
    } else {
      return value.toI32()
    }
  }

  set date(value: i32) {
    this.set('date', Value.fromI32(value))
  }

  get volumeETH(): BigDecimal {
    const value = this.get('volumeETH')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set volumeETH(value: BigDecimal) {
    this.set('volumeETH', Value.fromBigDecimal(value))
  }

  get volumeUSD(): BigDecimal {
    const value = this.get('volumeUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set volumeUSD(value: BigDecimal) {
    this.set('volumeUSD', Value.fromBigDecimal(value))
  }

  get volumeUSDUntracked(): BigDecimal {
    const value = this.get('volumeUSDUntracked')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set volumeUSDUntracked(value: BigDecimal) {
    this.set('volumeUSDUntracked', Value.fromBigDecimal(value))
  }

  get feesUSD(): BigDecimal {
    const value = this.get('feesUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set feesUSD(value: BigDecimal) {
    this.set('feesUSD', Value.fromBigDecimal(value))
  }

  get txCount(): BigInt {
    const value = this.get('txCount')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set txCount(value: BigInt) {
    this.set('txCount', Value.fromBigInt(value))
  }

  get tvlUSD(): BigDecimal {
    const value = this.get('tvlUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set tvlUSD(value: BigDecimal) {
    this.set('tvlUSD', Value.fromBigDecimal(value))
  }
}

export class PoolDayData extends Entity {
  constructor(id: string) {
    super()
    this.set('id', Value.fromString(id))
  }

  save(): void {
    const id = this.get('id')
    assert(id != null, 'Cannot save PoolDayData entity without an ID')
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PoolDayData must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      )
      store.set('PoolDayData', id.toString(), this)
    }
  }

  static loadInBlock(id: string): PoolDayData | null {
    return changetype<PoolDayData | null>(store.get_in_block('PoolDayData', id))
  }

  static load(id: string): PoolDayData | null {
    return changetype<PoolDayData | null>(store.get('PoolDayData', id))
  }

  get id(): string {
    const value = this.get('id')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set id(value: string) {
    this.set('id', Value.fromString(value))
  }

  get date(): i32 {
    const value = this.get('date')
    if (!value || value.kind == ValueKind.NULL) {
      return 0
    } else {
      return value.toI32()
    }
  }

  set date(value: i32) {
    this.set('date', Value.fromI32(value))
  }

  get pool(): string {
    const value = this.get('pool')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set pool(value: string) {
    this.set('pool', Value.fromString(value))
  }

  get liquidity(): BigInt {
    const value = this.get('liquidity')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set liquidity(value: BigInt) {
    this.set('liquidity', Value.fromBigInt(value))
  }

  get sqrtPrice(): BigInt {
    const value = this.get('sqrtPrice')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set sqrtPrice(value: BigInt) {
    this.set('sqrtPrice', Value.fromBigInt(value))
  }

  get token0Price(): BigDecimal {
    const value = this.get('token0Price')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set token0Price(value: BigDecimal) {
    this.set('token0Price', Value.fromBigDecimal(value))
  }

  get token1Price(): BigDecimal {
    const value = this.get('token1Price')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set token1Price(value: BigDecimal) {
    this.set('token1Price', Value.fromBigDecimal(value))
  }

  get tick(): BigInt | null {
    const value = this.get('tick')
    if (!value || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toBigInt()
    }
  }

  set tick(value: BigInt | null) {
    if (!value) {
      this.unset('tick')
    } else {
      this.set('tick', Value.fromBigInt(<BigInt>value))
    }
  }

  get tvlUSD(): BigDecimal {
    const value = this.get('tvlUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set tvlUSD(value: BigDecimal) {
    this.set('tvlUSD', Value.fromBigDecimal(value))
  }

  get volumeToken0(): BigDecimal {
    const value = this.get('volumeToken0')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set volumeToken0(value: BigDecimal) {
    this.set('volumeToken0', Value.fromBigDecimal(value))
  }

  get volumeToken1(): BigDecimal {
    const value = this.get('volumeToken1')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set volumeToken1(value: BigDecimal) {
    this.set('volumeToken1', Value.fromBigDecimal(value))
  }

  get volumeUSD(): BigDecimal {
    const value = this.get('volumeUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set volumeUSD(value: BigDecimal) {
    this.set('volumeUSD', Value.fromBigDecimal(value))
  }

  get feesUSD(): BigDecimal {
    const value = this.get('feesUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set feesUSD(value: BigDecimal) {
    this.set('feesUSD', Value.fromBigDecimal(value))
  }

  get txCount(): BigInt {
    const value = this.get('txCount')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set txCount(value: BigInt) {
    this.set('txCount', Value.fromBigInt(value))
  }

  get open(): BigDecimal {
    const value = this.get('open')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set open(value: BigDecimal) {
    this.set('open', Value.fromBigDecimal(value))
  }

  get high(): BigDecimal {
    const value = this.get('high')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set high(value: BigDecimal) {
    this.set('high', Value.fromBigDecimal(value))
  }

  get low(): BigDecimal {
    const value = this.get('low')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set low(value: BigDecimal) {
    this.set('low', Value.fromBigDecimal(value))
  }

  get close(): BigDecimal {
    const value = this.get('close')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set close(value: BigDecimal) {
    this.set('close', Value.fromBigDecimal(value))
  }
}

export class PoolHourData extends Entity {
  constructor(id: string) {
    super()
    this.set('id', Value.fromString(id))
  }

  save(): void {
    const id = this.get('id')
    assert(id != null, 'Cannot save PoolHourData entity without an ID')
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PoolHourData must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      )
      store.set('PoolHourData', id.toString(), this)
    }
  }

  static loadInBlock(id: string): PoolHourData | null {
    return changetype<PoolHourData | null>(store.get_in_block('PoolHourData', id))
  }

  static load(id: string): PoolHourData | null {
    return changetype<PoolHourData | null>(store.get('PoolHourData', id))
  }

  get id(): string {
    const value = this.get('id')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set id(value: string) {
    this.set('id', Value.fromString(value))
  }

  get periodStartUnix(): i32 {
    const value = this.get('periodStartUnix')
    if (!value || value.kind == ValueKind.NULL) {
      return 0
    } else {
      return value.toI32()
    }
  }

  set periodStartUnix(value: i32) {
    this.set('periodStartUnix', Value.fromI32(value))
  }

  get pool(): string {
    const value = this.get('pool')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set pool(value: string) {
    this.set('pool', Value.fromString(value))
  }

  get liquidity(): BigInt {
    const value = this.get('liquidity')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set liquidity(value: BigInt) {
    this.set('liquidity', Value.fromBigInt(value))
  }

  get sqrtPrice(): BigInt {
    const value = this.get('sqrtPrice')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set sqrtPrice(value: BigInt) {
    this.set('sqrtPrice', Value.fromBigInt(value))
  }

  get token0Price(): BigDecimal {
    const value = this.get('token0Price')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set token0Price(value: BigDecimal) {
    this.set('token0Price', Value.fromBigDecimal(value))
  }

  get token1Price(): BigDecimal {
    const value = this.get('token1Price')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set token1Price(value: BigDecimal) {
    this.set('token1Price', Value.fromBigDecimal(value))
  }

  get tick(): BigInt | null {
    const value = this.get('tick')
    if (!value || value.kind == ValueKind.NULL) {
      return null
    } else {
      return value.toBigInt()
    }
  }

  set tick(value: BigInt | null) {
    if (!value) {
      this.unset('tick')
    } else {
      this.set('tick', Value.fromBigInt(<BigInt>value))
    }
  }

  get tvlUSD(): BigDecimal {
    const value = this.get('tvlUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set tvlUSD(value: BigDecimal) {
    this.set('tvlUSD', Value.fromBigDecimal(value))
  }

  get volumeToken0(): BigDecimal {
    const value = this.get('volumeToken0')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set volumeToken0(value: BigDecimal) {
    this.set('volumeToken0', Value.fromBigDecimal(value))
  }

  get volumeToken1(): BigDecimal {
    const value = this.get('volumeToken1')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set volumeToken1(value: BigDecimal) {
    this.set('volumeToken1', Value.fromBigDecimal(value))
  }

  get volumeUSD(): BigDecimal {
    const value = this.get('volumeUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set volumeUSD(value: BigDecimal) {
    this.set('volumeUSD', Value.fromBigDecimal(value))
  }

  get feesUSD(): BigDecimal {
    const value = this.get('feesUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set feesUSD(value: BigDecimal) {
    this.set('feesUSD', Value.fromBigDecimal(value))
  }

  get txCount(): BigInt {
    const value = this.get('txCount')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set txCount(value: BigInt) {
    this.set('txCount', Value.fromBigInt(value))
  }

  get open(): BigDecimal {
    const value = this.get('open')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set open(value: BigDecimal) {
    this.set('open', Value.fromBigDecimal(value))
  }

  get high(): BigDecimal {
    const value = this.get('high')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set high(value: BigDecimal) {
    this.set('high', Value.fromBigDecimal(value))
  }

  get low(): BigDecimal {
    const value = this.get('low')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set low(value: BigDecimal) {
    this.set('low', Value.fromBigDecimal(value))
  }

  get close(): BigDecimal {
    const value = this.get('close')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set close(value: BigDecimal) {
    this.set('close', Value.fromBigDecimal(value))
  }
}

export class TokenDayData extends Entity {
  constructor(id: string) {
    super()
    this.set('id', Value.fromString(id))
  }

  save(): void {
    const id = this.get('id')
    assert(id != null, 'Cannot save TokenDayData entity without an ID')
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TokenDayData must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      )
      store.set('TokenDayData', id.toString(), this)
    }
  }

  static loadInBlock(id: string): TokenDayData | null {
    return changetype<TokenDayData | null>(store.get_in_block('TokenDayData', id))
  }

  static load(id: string): TokenDayData | null {
    return changetype<TokenDayData | null>(store.get('TokenDayData', id))
  }

  get id(): string {
    const value = this.get('id')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set id(value: string) {
    this.set('id', Value.fromString(value))
  }

  get date(): i32 {
    const value = this.get('date')
    if (!value || value.kind == ValueKind.NULL) {
      return 0
    } else {
      return value.toI32()
    }
  }

  set date(value: i32) {
    this.set('date', Value.fromI32(value))
  }

  get token(): string {
    const value = this.get('token')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set token(value: string) {
    this.set('token', Value.fromString(value))
  }

  get volume(): BigDecimal {
    const value = this.get('volume')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set volume(value: BigDecimal) {
    this.set('volume', Value.fromBigDecimal(value))
  }

  get volumeUSD(): BigDecimal {
    const value = this.get('volumeUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set volumeUSD(value: BigDecimal) {
    this.set('volumeUSD', Value.fromBigDecimal(value))
  }

  get untrackedVolumeUSD(): BigDecimal {
    const value = this.get('untrackedVolumeUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set untrackedVolumeUSD(value: BigDecimal) {
    this.set('untrackedVolumeUSD', Value.fromBigDecimal(value))
  }

  get totalValueLocked(): BigDecimal {
    const value = this.get('totalValueLocked')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set totalValueLocked(value: BigDecimal) {
    this.set('totalValueLocked', Value.fromBigDecimal(value))
  }

  get totalValueLockedUSD(): BigDecimal {
    const value = this.get('totalValueLockedUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set totalValueLockedUSD(value: BigDecimal) {
    this.set('totalValueLockedUSD', Value.fromBigDecimal(value))
  }

  get priceUSD(): BigDecimal {
    const value = this.get('priceUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set priceUSD(value: BigDecimal) {
    this.set('priceUSD', Value.fromBigDecimal(value))
  }

  get feesUSD(): BigDecimal {
    const value = this.get('feesUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set feesUSD(value: BigDecimal) {
    this.set('feesUSD', Value.fromBigDecimal(value))
  }

  get open(): BigDecimal {
    const value = this.get('open')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set open(value: BigDecimal) {
    this.set('open', Value.fromBigDecimal(value))
  }

  get high(): BigDecimal {
    const value = this.get('high')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set high(value: BigDecimal) {
    this.set('high', Value.fromBigDecimal(value))
  }

  get low(): BigDecimal {
    const value = this.get('low')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set low(value: BigDecimal) {
    this.set('low', Value.fromBigDecimal(value))
  }

  get close(): BigDecimal {
    const value = this.get('close')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set close(value: BigDecimal) {
    this.set('close', Value.fromBigDecimal(value))
  }
}

export class TokenHourData extends Entity {
  constructor(id: string) {
    super()
    this.set('id', Value.fromString(id))
  }

  save(): void {
    const id = this.get('id')
    assert(id != null, 'Cannot save TokenHourData entity without an ID')
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TokenHourData must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      )
      store.set('TokenHourData', id.toString(), this)
    }
  }

  static loadInBlock(id: string): TokenHourData | null {
    return changetype<TokenHourData | null>(store.get_in_block('TokenHourData', id))
  }

  static load(id: string): TokenHourData | null {
    return changetype<TokenHourData | null>(store.get('TokenHourData', id))
  }

  get id(): string {
    const value = this.get('id')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set id(value: string) {
    this.set('id', Value.fromString(value))
  }

  get periodStartUnix(): i32 {
    const value = this.get('periodStartUnix')
    if (!value || value.kind == ValueKind.NULL) {
      return 0
    } else {
      return value.toI32()
    }
  }

  set periodStartUnix(value: i32) {
    this.set('periodStartUnix', Value.fromI32(value))
  }

  get token(): string {
    const value = this.get('token')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set token(value: string) {
    this.set('token', Value.fromString(value))
  }

  get volume(): BigDecimal {
    const value = this.get('volume')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set volume(value: BigDecimal) {
    this.set('volume', Value.fromBigDecimal(value))
  }

  get volumeUSD(): BigDecimal {
    const value = this.get('volumeUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set volumeUSD(value: BigDecimal) {
    this.set('volumeUSD', Value.fromBigDecimal(value))
  }

  get untrackedVolumeUSD(): BigDecimal {
    const value = this.get('untrackedVolumeUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set untrackedVolumeUSD(value: BigDecimal) {
    this.set('untrackedVolumeUSD', Value.fromBigDecimal(value))
  }

  get totalValueLocked(): BigDecimal {
    const value = this.get('totalValueLocked')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set totalValueLocked(value: BigDecimal) {
    this.set('totalValueLocked', Value.fromBigDecimal(value))
  }

  get totalValueLockedUSD(): BigDecimal {
    const value = this.get('totalValueLockedUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set totalValueLockedUSD(value: BigDecimal) {
    this.set('totalValueLockedUSD', Value.fromBigDecimal(value))
  }

  get priceUSD(): BigDecimal {
    const value = this.get('priceUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set priceUSD(value: BigDecimal) {
    this.set('priceUSD', Value.fromBigDecimal(value))
  }

  get feesUSD(): BigDecimal {
    const value = this.get('feesUSD')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set feesUSD(value: BigDecimal) {
    this.set('feesUSD', Value.fromBigDecimal(value))
  }

  get open(): BigDecimal {
    const value = this.get('open')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set open(value: BigDecimal) {
    this.set('open', Value.fromBigDecimal(value))
  }

  get high(): BigDecimal {
    const value = this.get('high')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set high(value: BigDecimal) {
    this.set('high', Value.fromBigDecimal(value))
  }

  get low(): BigDecimal {
    const value = this.get('low')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set low(value: BigDecimal) {
    this.set('low', Value.fromBigDecimal(value))
  }

  get close(): BigDecimal {
    const value = this.get('close')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigDecimal()
    }
  }

  set close(value: BigDecimal) {
    this.set('close', Value.fromBigDecimal(value))
  }
}

export class Position extends Entity {
  constructor(id: string) {
    super()
    this.set('id', Value.fromString(id))
  }

  save(): void {
    const id = this.get('id')
    assert(id != null, 'Cannot save Position entity without an ID')
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Position must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      )
      store.set('Position', id.toString(), this)
    }
  }

  static loadInBlock(id: string): Position | null {
    return changetype<Position | null>(store.get_in_block('Position', id))
  }

  static load(id: string): Position | null {
    return changetype<Position | null>(store.get('Position', id))
  }

  get id(): string {
    const value = this.get('id')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set id(value: string) {
    this.set('id', Value.fromString(value))
  }

  get tokenId(): BigInt {
    const value = this.get('tokenId')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set tokenId(value: BigInt) {
    this.set('tokenId', Value.fromBigInt(value))
  }

  get owner(): string {
    const value = this.get('owner')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set owner(value: string) {
    this.set('owner', Value.fromString(value))
  }

  get origin(): string {
    const value = this.get('origin')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set origin(value: string) {
    this.set('origin', Value.fromString(value))
  }

  get createdAtTimestamp(): BigInt {
    const value = this.get('createdAtTimestamp')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set createdAtTimestamp(value: BigInt) {
    this.set('createdAtTimestamp', Value.fromBigInt(value))
  }

  get subscriptions(): SubscribeLoader {
    return new SubscribeLoader('Position', this.get('id')!.toString(), 'subscriptions')
  }

  get unsubscriptions(): UnsubscribeLoader {
    return new UnsubscribeLoader('Position', this.get('id')!.toString(), 'unsubscriptions')
  }

  get transfers(): TransferLoader {
    return new TransferLoader('Position', this.get('id')!.toString(), 'transfers')
  }
}

export class Subscribe extends Entity {
  constructor(id: string) {
    super()
    this.set('id', Value.fromString(id))
  }

  save(): void {
    const id = this.get('id')
    assert(id != null, 'Cannot save Subscribe entity without an ID')
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Subscribe must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      )
      store.set('Subscribe', id.toString(), this)
    }
  }

  static loadInBlock(id: string): Subscribe | null {
    return changetype<Subscribe | null>(store.get_in_block('Subscribe', id))
  }

  static load(id: string): Subscribe | null {
    return changetype<Subscribe | null>(store.get('Subscribe', id))
  }

  get id(): string {
    const value = this.get('id')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set id(value: string) {
    this.set('id', Value.fromString(value))
  }

  get tokenId(): BigInt {
    const value = this.get('tokenId')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set tokenId(value: BigInt) {
    this.set('tokenId', Value.fromBigInt(value))
  }

  get address(): string {
    const value = this.get('address')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set address(value: string) {
    this.set('address', Value.fromString(value))
  }

  get transaction(): string {
    const value = this.get('transaction')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set transaction(value: string) {
    this.set('transaction', Value.fromString(value))
  }

  get logIndex(): BigInt {
    const value = this.get('logIndex')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set logIndex(value: BigInt) {
    this.set('logIndex', Value.fromBigInt(value))
  }

  get timestamp(): BigInt {
    const value = this.get('timestamp')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set timestamp(value: BigInt) {
    this.set('timestamp', Value.fromBigInt(value))
  }

  get origin(): string {
    const value = this.get('origin')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set origin(value: string) {
    this.set('origin', Value.fromString(value))
  }

  get position(): string {
    const value = this.get('position')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set position(value: string) {
    this.set('position', Value.fromString(value))
  }
}

export class Unsubscribe extends Entity {
  constructor(id: string) {
    super()
    this.set('id', Value.fromString(id))
  }

  save(): void {
    const id = this.get('id')
    assert(id != null, 'Cannot save Unsubscribe entity without an ID')
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Unsubscribe must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      )
      store.set('Unsubscribe', id.toString(), this)
    }
  }

  static loadInBlock(id: string): Unsubscribe | null {
    return changetype<Unsubscribe | null>(store.get_in_block('Unsubscribe', id))
  }

  static load(id: string): Unsubscribe | null {
    return changetype<Unsubscribe | null>(store.get('Unsubscribe', id))
  }

  get id(): string {
    const value = this.get('id')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set id(value: string) {
    this.set('id', Value.fromString(value))
  }

  get tokenId(): BigInt {
    const value = this.get('tokenId')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set tokenId(value: BigInt) {
    this.set('tokenId', Value.fromBigInt(value))
  }

  get address(): string {
    const value = this.get('address')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set address(value: string) {
    this.set('address', Value.fromString(value))
  }

  get transaction(): string {
    const value = this.get('transaction')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set transaction(value: string) {
    this.set('transaction', Value.fromString(value))
  }

  get logIndex(): BigInt {
    const value = this.get('logIndex')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set logIndex(value: BigInt) {
    this.set('logIndex', Value.fromBigInt(value))
  }

  get timestamp(): BigInt {
    const value = this.get('timestamp')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set timestamp(value: BigInt) {
    this.set('timestamp', Value.fromBigInt(value))
  }

  get origin(): string {
    const value = this.get('origin')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set origin(value: string) {
    this.set('origin', Value.fromString(value))
  }

  get position(): string {
    const value = this.get('position')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set position(value: string) {
    this.set('position', Value.fromString(value))
  }
}

export class Transfer extends Entity {
  constructor(id: string) {
    super()
    this.set('id', Value.fromString(id))
  }

  save(): void {
    const id = this.get('id')
    assert(id != null, 'Cannot save Transfer entity without an ID')
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Transfer must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      )
      store.set('Transfer', id.toString(), this)
    }
  }

  static loadInBlock(id: string): Transfer | null {
    return changetype<Transfer | null>(store.get_in_block('Transfer', id))
  }

  static load(id: string): Transfer | null {
    return changetype<Transfer | null>(store.get('Transfer', id))
  }

  get id(): string {
    const value = this.get('id')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set id(value: string) {
    this.set('id', Value.fromString(value))
  }

  get tokenId(): BigInt {
    const value = this.get('tokenId')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set tokenId(value: BigInt) {
    this.set('tokenId', Value.fromBigInt(value))
  }

  get from(): string {
    const value = this.get('from')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set from(value: string) {
    this.set('from', Value.fromString(value))
  }

  get to(): string {
    const value = this.get('to')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set to(value: string) {
    this.set('to', Value.fromString(value))
  }

  get transaction(): string {
    const value = this.get('transaction')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set transaction(value: string) {
    this.set('transaction', Value.fromString(value))
  }

  get logIndex(): BigInt {
    const value = this.get('logIndex')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set logIndex(value: BigInt) {
    this.set('logIndex', Value.fromBigInt(value))
  }

  get timestamp(): BigInt {
    const value = this.get('timestamp')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toBigInt()
    }
  }

  set timestamp(value: BigInt) {
    this.set('timestamp', Value.fromBigInt(value))
  }

  get origin(): string {
    const value = this.get('origin')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set origin(value: string) {
    this.set('origin', Value.fromString(value))
  }

  get position(): string {
    const value = this.get('position')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set position(value: string) {
    this.set('position', Value.fromString(value))
  }
}

export class EulerSwapHook extends Entity {
  constructor(id: string) {
    super()
    this.set('id', Value.fromString(id))
  }

  save(): void {
    const id = this.get('id')
    assert(id != null, 'Cannot save EulerSwapHook entity without an ID')
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type EulerSwapHook must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      )
      store.set('EulerSwapHook', id.toString(), this)
    }
  }

  static loadInBlock(id: string): EulerSwapHook | null {
    return changetype<EulerSwapHook | null>(store.get_in_block('EulerSwapHook', id))
  }

  static load(id: string): EulerSwapHook | null {
    return changetype<EulerSwapHook | null>(store.get('EulerSwapHook', id))
  }

  get id(): string {
    const value = this.get('id')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set id(value: string) {
    this.set('id', Value.fromString(value))
  }

  get hook(): string {
    const value = this.get('hook')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set hook(value: string) {
    this.set('hook', Value.fromString(value))
  }

  get eulerAccount(): string {
    const value = this.get('eulerAccount')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set eulerAccount(value: string) {
    this.set('eulerAccount', Value.fromString(value))
  }

  get asset0(): string {
    const value = this.get('asset0')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set asset0(value: string) {
    this.set('asset0', Value.fromString(value))
  }

  get asset1(): string {
    const value = this.get('asset1')
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error('Cannot return null for a required field.')
    } else {
      return value.toString()
    }
  }

  set asset1(value: string) {
    this.set('asset1', Value.fromString(value))
  }
}

export class TokenDayDataLoader extends Entity {
  _entity: string
  _field: string
  _id: string

  constructor(entity: string, id: string, field: string) {
    super()
    this._entity = entity
    this._id = id
    this._field = field
  }

  load(): TokenDayData[] {
    const value = store.loadRelated(this._entity, this._id, this._field)
    return changetype<TokenDayData[]>(value)
  }
}

export class PoolHourDataLoader extends Entity {
  _entity: string
  _field: string
  _id: string

  constructor(entity: string, id: string, field: string) {
    super()
    this._entity = entity
    this._id = id
    this._field = field
  }

  load(): PoolHourData[] {
    const value = store.loadRelated(this._entity, this._id, this._field)
    return changetype<PoolHourData[]>(value)
  }
}

export class PoolDayDataLoader extends Entity {
  _entity: string
  _field: string
  _id: string

  constructor(entity: string, id: string, field: string) {
    super()
    this._entity = entity
    this._id = id
    this._field = field
  }

  load(): PoolDayData[] {
    const value = store.loadRelated(this._entity, this._id, this._field)
    return changetype<PoolDayData[]>(value)
  }
}

export class ModifyLiquidityLoader extends Entity {
  _entity: string
  _field: string
  _id: string

  constructor(entity: string, id: string, field: string) {
    super()
    this._entity = entity
    this._id = id
    this._field = field
  }

  load(): ModifyLiquidity[] {
    const value = store.loadRelated(this._entity, this._id, this._field)
    return changetype<ModifyLiquidity[]>(value)
  }
}

export class SwapLoader extends Entity {
  _entity: string
  _field: string
  _id: string

  constructor(entity: string, id: string, field: string) {
    super()
    this._entity = entity
    this._id = id
    this._field = field
  }

  load(): Swap[] {
    const value = store.loadRelated(this._entity, this._id, this._field)
    return changetype<Swap[]>(value)
  }
}

export class TickLoader extends Entity {
  _entity: string
  _field: string
  _id: string

  constructor(entity: string, id: string, field: string) {
    super()
    this._entity = entity
    this._id = id
    this._field = field
  }

  load(): Tick[] {
    const value = store.loadRelated(this._entity, this._id, this._field)
    return changetype<Tick[]>(value)
  }
}

export class TransferLoader extends Entity {
  _entity: string
  _field: string
  _id: string

  constructor(entity: string, id: string, field: string) {
    super()
    this._entity = entity
    this._id = id
    this._field = field
  }

  load(): Transfer[] {
    const value = store.loadRelated(this._entity, this._id, this._field)
    return changetype<Transfer[]>(value)
  }
}

export class SubscribeLoader extends Entity {
  _entity: string
  _field: string
  _id: string

  constructor(entity: string, id: string, field: string) {
    super()
    this._entity = entity
    this._id = id
    this._field = field
  }

  load(): Subscribe[] {
    const value = store.loadRelated(this._entity, this._id, this._field)
    return changetype<Subscribe[]>(value)
  }
}

export class UnsubscribeLoader extends Entity {
  _entity: string
  _field: string
  _id: string

  constructor(entity: string, id: string, field: string) {
    super()
    this._entity = entity
    this._id = id
    this._field = field
  }

  load(): Unsubscribe[] {
    const value = store.loadRelated(this._entity, this._id, this._field)
    return changetype<Unsubscribe[]>(value)
  }
}
